"""Integration test demonstrating the KeyError issue with DictRowFactory and enum composite types."""

import pytest
from unittest.mock import AsyncMock
from enum import Enum
from dataclasses import dataclass
from typing import Optional

import psycopg


# Define the enums and dataclass that would be generated by sql2pyapi
class StatusType(Enum):
    pending = 'pending'
    active = 'active'
    inactive = 'inactive'
    deleted = 'deleted'


class UserRole(Enum):
    admin = 'admin'
    moderator = 'moderator'
    user = 'user'
    guest = 'guest'


@dataclass
class UserWithEnums:
    user_id: int
    username: str
    status: str  # String type initially, converted to enum after instantiation
    role: str    # String type initially, converted to enum after instantiation


# This is a simplified version of the code generated by sql2pyapi for a function
# returning a composite type with enum fields. The key issue is that it uses
# explicit index access (row[0], row[1], etc.) instead of tuple unpacking (*row)
# when enum columns are present.
async def get_user_with_enums_index_access(conn: psycopg.AsyncConnection, user_id: int) -> Optional[UserWithEnums]:
    """Function that demonstrates the issue with index access for enum columns."""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_with_enums(%s)", [user_id])
        row = await cur.fetchone()
        if row is None:
            return None
        try:
            # This is the problematic part - using explicit index access
            # This works with tuple row factory but fails with dict row factory
            instance = UserWithEnums(
                user_id=row[0],  # KeyError: 0 if row is dict
                username=row[1],  # KeyError: 1 if row is dict
                status=row[2],    # KeyError: 2 if row is dict
                role=row[3]       # KeyError: 3 if row is dict
            )
            
            # Convert string values to enum objects
            if instance.status is not None:
                instance.status = StatusType(instance.status)
            if instance.role is not None:
                instance.role = UserRole(instance.role)
                
            return instance
        except TypeError as e:
            # This exception handler is intended to catch errors when using
            # non-tuple row factories, but KeyError happens before we get here
            raise TypeError(
                f"Failed to map single row result to dataclass UserWithEnums. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )


# This is how the function should be implemented to work with both tuple and dict row factories
async def get_user_with_enums_tuple_unpacking(conn: psycopg.AsyncConnection, user_id: int) -> Optional[UserWithEnums]:
    """Function that demonstrates the correct approach using tuple unpacking."""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_with_enums(%s)", [user_id])
        row = await cur.fetchone()
        if row is None:
            return None
        try:
            # This is the correct approach - using tuple unpacking (*row)
            # This works with tuple row factory and properly raises TypeError with dict row factory
            instance = UserWithEnums(*row)
            
            # Convert string values to enum objects
            if instance.status is not None:
                instance.status = StatusType(instance.status)
            if instance.role is not None:
                instance.role = UserRole(instance.role)
                
            return instance
        except (TypeError, KeyError) as e:
            # Now this exception handler will properly catch both TypeError and KeyError
            # when using dict row factory
            raise TypeError(
                f"Failed to map single row result to dataclass UserWithEnums. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )


@pytest.mark.asyncio
async def test_dict_row_with_index_access_fails():
    """Test that demonstrates the KeyError issue with dict_row and index access."""
    # Set up mock connection with dict_row factory
    mock_conn = AsyncMock(spec=psycopg.AsyncConnection)
    mock_cursor = AsyncMock(spec=psycopg.AsyncCursor)
    
    # Configure mock cursor
    mock_cursor.description = [
        ("user_id",), ("username",), ("status",), ("role",)
    ]
    
    # Simulate fetchone returning a dictionary (as dict_row would)
    mock_dict_row = {
        "user_id": 1,
        "username": "admin_user",
        "status": "active",
        "role": "admin"
    }
    mock_cursor.fetchone.return_value = mock_dict_row
    
    # Setup context manager behavior
    mock_conn.cursor.return_value.__aenter__.return_value = mock_cursor
    mock_conn.cursor.return_value.__aexit__.return_value = None
    
    # Call the function with index access - should raise KeyError
    with pytest.raises(KeyError) as excinfo:
        await get_user_with_enums_index_access(mock_conn, 1)
    
    # Verify it's the expected KeyError for index access
    assert "0" in str(excinfo.value)


@pytest.mark.asyncio
async def test_dict_row_with_tuple_unpacking_raises_value_error():
    """Test that demonstrates the behavior with dict row factory after the fix.
    
    With our fix, the code now progresses further and fails when trying to convert
    a dictionary key ('status') to an enum value, resulting in a ValueError.
    """
    # Set up mock connection with dict_row factory
    mock_conn = AsyncMock(spec=psycopg.AsyncConnection)
    mock_cursor = AsyncMock(spec=psycopg.AsyncCursor)
    
    # Configure mock cursor
    mock_cursor.description = [
        ("user_id",), ("username",), ("status",), ("role",)
    ]
    
    # Simulate fetchone returning a dictionary (as dict_row would)
    mock_dict_row = {
        "user_id": 1,
        "username": "admin_user",
        "status": "active",
        "role": "admin"
    }
    mock_cursor.fetchone.return_value = mock_dict_row
    
    # Setup context manager behavior
    mock_conn.cursor.return_value.__aenter__.return_value = mock_cursor
    mock_conn.cursor.return_value.__aexit__.return_value = None
    
    # With our fix, the code now progresses further and fails when trying to convert
    # a dictionary key ('status') to an enum value, resulting in a ValueError
    with pytest.raises(ValueError) as excinfo:
        await get_user_with_enums_tuple_unpacking(mock_conn, 1)
    
    # Verify it contains the expected error message
    assert "is not a valid StatusType" in str(excinfo.value)


@pytest.mark.asyncio
async def test_tuple_row_works_with_both_implementations():
    """Test that both implementations work with tuple row factory."""
    # Set up mock connection with tuple row factory
    mock_conn = AsyncMock(spec=psycopg.AsyncConnection)
    mock_cursor = AsyncMock(spec=psycopg.AsyncCursor)
    
    # Configure mock cursor
    mock_cursor.description = [
        ("user_id",), ("username",), ("status",), ("role",)
    ]
    
    # Simulate fetchone returning a tuple (as default row factory would)
    mock_tuple_row = (1, "admin_user", "active", "admin")
    mock_cursor.fetchone.return_value = mock_tuple_row
    
    # Setup context manager behavior
    mock_conn.cursor.return_value.__aenter__.return_value = mock_cursor
    mock_conn.cursor.return_value.__aexit__.return_value = None
    
    # Both implementations should work with tuple rows
    result1 = await get_user_with_enums_index_access(mock_conn, 1)
    assert isinstance(result1, UserWithEnums)
    assert result1.user_id == 1
    assert result1.username == "admin_user"
    assert isinstance(result1.status, StatusType)
    assert result1.status == StatusType.active
    assert isinstance(result1.role, UserRole)
    assert result1.role == UserRole.admin
    
    # Reset mock
    mock_cursor.fetchone.return_value = mock_tuple_row
    
    result2 = await get_user_with_enums_tuple_unpacking(mock_conn, 1)
    assert isinstance(result2, UserWithEnums)
    assert result2.user_id == 1
    assert result2.username == "admin_user"
    assert isinstance(result2.status, StatusType)
    assert result2.status == StatusType.active
    assert isinstance(result2.role, UserRole)
    assert result2.role == UserRole.admin
