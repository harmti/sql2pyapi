# SQL2PyAPI: SQL to Python Type-Safe API Generator

`sql2pyapi` generates type-safe async Python wrappers for PostgreSQL functions, creating a bridge between SQL and Python with proper type mapping.

```
┌───────────────┐
│ PostgreSQL    │
│ Functions     │───┐
└───────────────┘   │   ┌──────────────┐     ┌────────────────┐
                    ├──▶│ sql2pyapi    │────▶│ Python API     │
┌───────────────┐   │   │ Generator    │     │ Async Wrappers │
│ SQL Schema    │───┘   └──────────────┘     └────────────────┘
│ Definitions   │
└───────────────┘
```

## Quick Example

**Write SQL functions (your_functions.sql):**
```sql
CREATE FUNCTION get_user_by_id(p_user_id UUID)
RETURNS TABLE (
    id UUID,
    username TEXT,
    email TEXT,
    created_at TIMESTAMP
)
AS $$
    SELECT id, username, email, created_at 
    FROM users 
    WHERE id = p_user_id;
$$ LANGUAGE SQL;
```

**Generate Python API:**
```bash
sql2pyapi your_functions.sql user_api.py
```

**Use in your Python code:**
```python
import asyncio
from user_api import get_user_by_id, User

async def main():
    user = await get_user_by_id("123e4567-e89b-12d3-a456-426614174000")
    print(f"Found user: {user.username}")

asyncio.run(main())
```

## Why SQL2PyAPI?

### SQL Advantages for Complex Applications

SQL offers significant benefits for data-intensive applications. SQL2PyAPI helps you:

- Write queries in SQL where it excels - aggregations, joins, window functions
- Use database-native features like triggers, constraints, and stored procedures
- Control query optimization with direct SQL access
- See exactly what SQL is executed, with clear error messages

### Benefits for Larger Applications

- Provides precise control over database queries
- Helps prevent N+1 query problems through optimized SQL
- Enables separation of data access from business logic
- Supports layered architecture design

### Technical Features

- Type-safe interfaces with Python type hints
- Async implementation with psycopg3
- Compatible with database migration workflows
- Works well with SQL generation tools and AI assistants

## Usage

The tool provides a command-line interface:

```bash
sql2pyapi <input_sql_file> <output_python_file> [options]
```

**Arguments:**

*   `<input_sql_file>`: Path to the input `.sql` file containing function definitions (and optionally table/type definitions).
*   `<output_python_file>`: Path where the generated Python API file will be written.

**Options:**

*   `--schema-file FILE`: Optional path to a separate `.sql` file containing table/type schema definitions (`CREATE TABLE`, `CREATE TYPE`).
*   `--no-helpers`: Do not include helper functions (`get_optional`, `get_required`) in the generated output.
*   `--allow-missing-schemas`: If specified, the tool will log a warning and generate placeholder comments (instead of failing) when it encounters a function returning a table/type whose schema definition (`CREATE TABLE`/`CREATE TYPE`) cannot be found. **Note:** Using this flag may result in generated code that fails at runtime with a `NameError` if functions returning the missing types are called.
*   `--verbose` / `-v`: Enable verbose (DEBUG) logging.

**Default Behavior (Schema Handling):**

By default, `sql2pyapi` requires schema definitions (`CREATE TABLE` or `CREATE TYPE`) for any tables or composite types returned by your SQL functions (unless they are simple scalar types or anonymous `RECORD`s). If a required schema definition is missing from the input SQL or the provided `--schema-file`, the tool will **fail with an error**, preventing the generation of potentially broken code.

If you understand the risks and want the tool to proceed despite missing schemas (logging warnings and generating placeholders instead), use the `--allow-missing-schemas` flag.

**Example:**

```bash
# Basic usage (will fail if schemas for returned tables/types are missing)
sql2pyapi functions.sql generated_api.py --schema-file schema.sql

# Allow generation even if some schemas are missing (will warn and create placeholders - potential runtime errors!)
sql2pyapi functions.sql generated_api.py --schema-file schema.sql --allow-missing-schemas
```

### Important: Database Connection Configuration (Row Factory)

**The Python code generated by `sql2pyapi` expects the database connection (e.g., `psycopg.AsyncConnection`) to be configured with the default *tuple row factory*.**

This means that database results are returned as simple tuples.

```python
import psycopg

# CORRECT: Use the default tuple row factory (or psycopg.rows.tuple_row explicitly)
async with await psycopg.AsyncConnection.connect("dbname=mydb user=user") as conn:
    # ... use generated API functions ...
    pass 
```

**Why this requirement?**

*   **Simplicity & Performance:** Tuple unpacking (`*row`) is efficient and leads to cleaner generated code.
*   **Clear Contract:** It establishes a predictable interface between the database call and the Python code.
*   **Avoids Guesswork:** The tool doesn't try to guess the row format, which could hide configuration issues.

**Using Dictionary Row Factories (e.g., `DictRow`)**

If your connection uses a dictionary-based row factory (like `psycopg.rows.dict_row`), the generated code will likely **fail** with a `TypeError` when trying to unpack results into dataclasses.

```python
import psycopg
from psycopg.rows import dict_row

# INCORRECT for generated code: Using dict_row will cause TypeErrors
async with await psycopg.AsyncConnection.connect("dbname=mydb user=user", row_factory=dict_row) as conn:
    # ... generated API functions will likely raise TypeError here ...
    pass
```

The error message will indicate that tuple unpacking failed and suggest checking the row factory configuration.

## Setup

We recommend using `uv` for managing dependencies:

1. **Create and activate a virtual environment:**
   ```bash
   uv venv
   source .venv/bin/activate # Or .venv\Scripts\activate on Windows
   ```

2. **Install dependencies:**
   ```bash
   uv pip install -e . # Installs the package in editable mode
   ```

## Features

- **Complete Type Mapping** from PostgreSQL to Python types
- **Dataclass Generation** for table returns
- **Async Functions** using psycopg3
- **Support for Complex Returns** (scalar, SETOF, TABLE, RECORD)
- **Composite Types** with automatic nested dataclass handling
- **Docstring Generation** from SQL comments
- **Pythonic Parameter Names** (removes prefixes like p_)

## Result Helper Functions (`get_optional`, `get_required`)

By default, `sql2pyapi` includes two helper functions in the generated Python file to simplify common patterns when dealing with function results:

- **`get_optional(result: Optional[List[T]] | Optional[T]) -> Optional[T]`**: 
    - Safely retrieves a single item from a result that might be `None`, an empty list, a list with one item, or a single item directly.
    - Returns the item if exactly one is found, otherwise returns `None`.
    - Useful when you expect zero or one result (e.g., from a `fetchone()` call).
    - Example: `user = get_optional(await cur.fetchone())`

- **`get_required(result: Optional[List[T]] | Optional[T]) -> T`**:
    - Retrieves a single item, similar to `get_optional`.
    - Raises a `ValueError` if the result is `None`, an empty list, or a list with more than one item.
    - Useful when you expect exactly one result and want an error if that condition isn't met.
    - Example: `user_id = get_required(await cur.fetchone())`

These helpers abstract away common `if row is None:` or `if len(rows) == 1:` checks.

If you prefer not to have these functions included in your generated code, you can use the `--no-helpers` command-line flag:

```bash
sql2pyapi functions.sql generated_api.py --no-helpers
```

## Detailed Type Support

* **SQL Parsing:**
  * Parses `CREATE FUNCTION` and `CREATE TABLE` statements
  * Extracts parameters, return types, and comments
  * Handles various return structures (scalar, TABLE, SETOF, RECORD)

* **Type Mapping:**
  * Maps PostgreSQL types to Python equivalents (uuid → UUID, text → str, etc.)
  * Handles array types (e.g., integer[] → List[int])
  * Automatically adds necessary imports

## Limitations and Future Work

* **Complex SQL:** Does not handle very complex SQL syntax within function bodies
* **Error Handling:** Generated code assumes successful execution
* **Dependencies:** Relies on psycopg3 and inflection
* **Custom Types:** Less common PostgreSQL types might map to Any

## Development

* Install development dependencies: `uv pip install -e ".[dev]"`
* Run tests: `pytest`
* Linting/Formatting: `ruff check .` and `ruff format .`

### Testing

The project includes unit, integration, and system tests. To run all tests, use the following command:

```bash
uv run pytest
```

This command will automatically discover and execute tests from `tests/unit`, `tests/integration`, and `tests/system` directories due to the configuration in `pyproject.toml`.

## Return Type Handling (`List` vs. `Optional`)

`sql2pyapi` aims for a predictable mapping from SQL function return types to Python type hints. A key aspect is how it determines whether a Python function should return a `List[...]` or an `Optional[...]`.

**The Rule:**

The **sole determinant** for using `List` versus `Optional` as the *outer* wrapper in the Python return type hint is the presence or absence of the `SETOF` keyword in the SQL function's `RETURNS` clause.

1.  **`RETURNS SETOF <type>`:**
    *   If your SQL function includes `SETOF` (e.g., `RETURNS SETOF integer`, `RETURNS SETOF users`, `RETURNS SETOF user_identity`), the generated Python function will **always** have a return type hint of `List[MappedType]` (e.g., `List[int]`, `List[User]`, `List[UserIdentity]`)).
    *   If the SQL function returns zero rows, the Python function will return an empty list (`[]`).

2.  **`RETURNS <type>` (No `SETOF`):**
    *   If your SQL function returns a single value, row, or composite type *without* `SETOF` (e.g., `RETURNS integer`, `RETURNS users`, `RETURNS user_identity`), the generated Python function will **always** have a return type hint of `Optional[MappedType]` (e.g., `Optional[int]`, `Optional[User]`, `Optional[UserIdentity]`)).
    *   This handles the common database pattern where a function designed to return a single row might return zero rows (e.g., `SELECT ... FROM users WHERE id = p_id LIMIT 1`). In such cases, the Python function will return `None`. If a row *is* found, it returns the mapped object/value.

3.  **`RETURNS VOID` or `PROCEDURE`:**
    *   Functions returning `VOID` or defined as `PROCEDURE` will result in a Python function with a return type hint of `None`.

**Examples:**

| SQL Function Signature                  | Generated Python Return Hint | Notes                                      |
| :-------------------------------------- | :--------------------------- | :----------------------------------------- |
| `RETURNS integer`                       | `Optional[int]`              | Returns `